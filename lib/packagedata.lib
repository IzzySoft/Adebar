##############################################################################
# Adebar © 2014, 2020 by Itzchak Rehberg
# This is part of the Adebar project, see https://codeberg.org/izzy/Adebar
# Protected by the GPLv2
# ----------------------------------------------------------------------------
# library to deal with package data (apps)
##############################################################################

# Mapping AndroidSDK to AndroidVersion
# SDK                                   5                               10                              15                              20                            25                            30
SDK2VER=("0" "1.0" "1.1" "1.5" "1.6" "2.0" "2.0.1" "2.1" "2.2" "2.3" "2.3.3" "3.0" "3.1" "3.2" "4.0" "4.0.3" "4.1" "4.2" "4.3" "4.4" "4.4W" "5.0" "5.1" "6.0" "7.0" "7.1" "8.0" "8.1" "9.0" "10.0" "11.0")

#
# Get app names by package names (if possible)
# $1: package name
# $2: path to apk file (for aapt)
# $3: whether to retrieve the app name if not found in cache
# $4: optional path to append to cache base dir. If set, only scan this (no AAPT, no update)
#
getAppname() {
  # Special cache dir?
  [[ -n "${CACHEDIR}" ]] && {
    if [[ -n "$4" && -d "${CACHEDIR}/appnames/${4}" ]]; then
      local CACHEDIR="${CACHEDIR}/appnames/${4}"
      local SCANONLY=1
    elif [[ -n "$4" ]]; then  # specified sub-cache doesn't exist
      echo "$1"
      return
    else
      local SCANONLY=0
      local CACHEDIR="${CACHEDIR}/appnames"
    fi
  }
  # Check cache first (fastest if we have it)
  if [[ -n "${CACHEDIR}" && -f "${CACHEDIR}/$1" ]]; then
    local name="$(cat "${CACHEDIR}/$1")"
    name="$(trim "$name")"
    if [[ -n "${name}" ]]; then
      echo "${name}"
      return
    fi
  fi

  # ScanOnly mode (special cache dir found)?
  if [[ $SCANONLY -ne 0 ]]; then
    echo "$1"
    return
  fi

  # still here, so not found in cache. Try AAPT (if we have it)
  if [[ $HAVE_AAPT -eq 1 ]]; then
    local str="$(adb ${ADBOPTS} shell "aapt d badging $2 2>/dev/null" | grep 'application: label' | sed -n "s/.*label\='\([^']*\)'.*/\1/p")" # label='Some App''
    str=${str//[$'\t\r\n']} # stupid ^M
    if [[ -n "${str}" ]]; then
      [[ -n "${CACHEDIR}" && -e "${CACHEDIR}" && ! -f "${CACHEDIR}/$1" ]] && echo -n $str > "${CACHEDIR}/$1"
      echo "${str}"
      return
    fi
  fi

  # not found in cache nor by AAPT: optionally call user script/function here (if defined)
  if [[ ${3} -gt 0 && -n "${APPNAME_CMD}" ]]; then
    name="$(${APPNAME_CMD} $1)"
    if [[ "${name}" != "$1" ]]; then
      echo "${name}" > "${CACHEDIR}/$1"
    fi
    echo "${name}"
    return
  fi

  # still here? So we found nothing. Return package_name then.
  echo "$1"
}


#
# Helpers for app usage stats
# credits to:
# - https://stackoverflow.com/questions/893585/how-to-parse-xml-in-bash
# - https://android.stackexchange.com/questions/116625/how-do-i-know-when-an-app-was-used-in-android
#
read_dom () {
    local IFS=\>
    read -d \< ENTITY CONTENT
    local RET=$?
    TAG_NAME=${ENTITY%% *}
    ATTRIBUTES=${ENTITY#* }
    return $RET
}
# Android JB + KK (verified: 4.1.2 on Cat SG2)
parse_dom_u4stat () {
    if [[ $TAG_NAME = "pkg" ]] ; then
        eval local $ATTRIBUTES
        currpkg="$name"
    elif [[ $TAG_NAME = "comp" ]] ; then
        eval local $ATTRIBUTES 2>/dev/null
        if [[ -z ${PK_LASTUSED[$currpkg]} || ${PK_LASTUSED[$currpkg]} -lt $lrt ]]; then
          PK_LASTUSED[$currpkg]=$lrt
        fi
    fi
}
#
# Now for the real thing
getAppUsage() {
  [[ ! -f "${CONFDIR}/usage-history.xml" ]] && return
  doProgress "- collecting app usage stats" 2
  currpkg=
  while read_dom; do
    parse_dom_u4stat
  done < "${CONFDIR}/usage-history.xml"

  for i in "${!PK_LASTUSED[@]}"; do
    ts=$((${PK_LASTUSED[$i]} / 1000)) # time is in ms
    if [[ "$(date -d @${ts} +"%Y")" = "1970" ]]; then PK_LASTUSED[$i]=
    else PK_LASTUSED[$i]="$(date -d @${ts} +"%Y-%m-%d %H:%M:%S")"
    fi
  done
}

#
# Collecting app storage details
#
declare -A PK_ASIZE
declare -A PK_CSIZE
declare -A PK_DSIZE
getAppStorageStats() {
  doProgress "- collecting app storage details" 2
  DSTATS=$(getAdbContent dumpsys_diskstats "adb ${ADBOPTS} shell dumpsys diskstats")
  re='Package Names: \[([^]]*)\]'
  if [[ $DSTATS =~ $re ]]; then
    PN=( ${BASH_REMATCH[1]//,/ } )
    re='App Sizes: \[([^]]*)\]'
    [[ $DSTATS =~ $re ]] && ASIZE=( ${BASH_REMATCH[1]//,/ } )
    re='App Data Sizes: \[([^]]*)\]'
    [[ $DSTATS =~ $re ]] && DSIZE=( ${BASH_REMATCH[1]//,/ } )
    re='Cache Sizes: \[([^]]*)\]'
    [[ $DSTATS =~ $re ]] && CSIZE=( ${BASH_REMATCH[1]//,/ } )
    declare -i acount=0
    while [[ $acount -lt ${#PN[@]} ]]; do
      pn=${PN[$acount]//\"/}
      PK_ASIZE[$pn]=${ASIZE[$acount]}
      PK_CSIZE[$pn]=${CSIZE[$acount]}
      PK_DSIZE[$pn]=${DSIZE[$acount]}
      acount+=1
    done
  fi
}


#
# Collect app details via dumpsys
#
declare -A PK_FLAGS     # (also needed by backup script: flags=[ SYSTEM HAS_CODE ALLOW_TASK_REPARENTING ALLOW_CLEAR_USER_DATA ALLOW_BACKUP LARGE_HEAP ]
declare -A PK_PRIVFLAGS # privateFlags=[ PRIVILEGED DEFAULT_TO_DEVICE_PROTECTED_STORAGE DIRECT_BOOT_AWARE RESIZEABLE_ACTIVITIES ]
getAppDetails() {
  local P_BLOCK="none" # none|pkglist|pkg|disabled|enabled|perms
  local P_PKGNAME=""   # name of the currently processed package
  local tmpstring=""
  local regex
  local appCategory=(game audio video image social news maps productivity)  # https://developer.android.com/reference/android/R.attr.html#appCategory
  local P_SKIP=(sharedUser pkg resourcePath nativeLibraryPath targetSdk timeStamp signatures permissionsFixed installPermissionsFixed pkgFlags pkgFlagsEx applicationInfo dexTimeStamp overlayTarget overlayCategory)
  declare -A PK_CODEPATH
  declare -A PK_VERSION
  declare -A PK_VERSIONCODE
  declare -A PK_MINSDK
  declare -A PK_TARGETSDK
  declare -A PK_SIGNINGVER
  declare -A PK_IDS           # UID/GID (from userId)
  declare -A PK_DATADIR
  declare -A PK_PRIMARYCPU
  declare -A PK_SECONDARYCPU
  declare -A PK_APPCATEGORY
  declare -A PK_SCREENSIZE
  declare -A PK_FIRSTINSTALL
  declare -A PK_LASTUPDATE
  declare -A PK_INSTALLERS    # per source
  PK_INSTALLERS[none]="unknown source"
  declare -A PK_INSTALLER     # per app
  declare -A PK_DISABLED      # list of components separated by spaces
  declare -A PK_MTKFLAGS      # mtkFlags=[ OPERATOR ]
  declare -A PK_USERS         # User 0:  installed=true stopped=false notLaunched=false enabled=0
  declare -A PK_LASTUSED      # Usage stats
  local tmp=$(mktemp)
  local PKGDUMP=$(mktemp)
  trap "rm -f -- '$PKGDUMP' '$tmp'" RETURN
  local SH_DISABLED="${OUTDIR}/deadReceivers.sh"

  doProgress "Generating app detail info"
  doProgress "- collecting data via dumpsys" 2
  copyAdbContent dumpsys_package "adb ${ADBOPTS} shell dumpsys package" $tmp
  grep -E -A99999 "^Packages:" $tmp | grep -E -B99999 "^Shared users:" > "${PKGDUMP}"

  # Parsing dump
  doProgress "- parsing package dump" 2
  while IFS='' read zeile; do # no idea why, but some dump lines are terminated using CRLF
    zeile="${zeile%"${zeile##*[![:space:]]}"}" #" rtrim (e.g. S7 Edge otherwise causes trouble)
    case ${P_BLOCK} in
      none)
        [[ "$zeile" != "Packages:" ]] && continue;
        P_BLOCK="pkglist"
        doProgress "  - Found package list marker" 4
        continue;
        ;;

      pkglist)
        if [[ "${zeile:0:11}" = "  Package [" ]]; then  # "  Package [com.google.android.location] (40e85638):"
          tmpstring="${zeile##*[}"                      # strip leading
          P_PKGNAME="${tmpstring%%]*}"                  # strip trailing
          P_BLOCK="pkg"
          doProgress "  - Package: $P_PKGNAME" 4
          continue
        fi
        ;;

      pkg)
        tmpstring="${zeile%%=*}"
        tmpstring="${tmpstring##*[[:space:]]}"
        # we skip some details here. Later we might decide to integrate them.
        in_array $tmpstring "${P_SKIP[@]}" && continue
        [[ "$zeile" = "    grantedPermissions:" ]] && continue
        [[ "$zeile" = "    usesOptionalLibraries:" ]] && continue
        [[ "$zeile" = "    usesLibraryFiles:" ]] && continue
        [[ "$zeile" = "    usesLibraries:" ]] && continue
        [[ "$zeile" = "    libraries:" ]] && continue
        [[ "$zeile" = "    overlay paths:" ]] && continue
        [[ "$zeile" = "    dynamic libraries:" ]] && continue
        regex='^\s+(dis|en)abledComponents:'
        [[ "${zeile:0:6}" = "      " && ! "${zeile}" =~ $regex ]] && continue
        [[ -z "${zeile%%* }" ]] && break # end of package list is an empty line, sometimes with spaces
        case "$tmpstring" in
          "codePath")
            PK_CODEPATH[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +codePath: ${PK_CODEPATH[$P_PKGNAME]}" 5
            continue
            ;;
          "versionCode")
            PK_VERSIONCODE[$P_PKGNAME]="${zeile#*=}"   # versionCode=1 minSdk=27 targetSdk=27
            PK_VERSIONCODE[$P_PKGNAME]="${PK_VERSIONCODE[$P_PKGNAME]%%[[:space:]]*}"
            # versionCode=906400000 minSdk=26 targetSdk=28
            re='minSdk=([0-9]+)'
            if [[ $zeile =~ $re ]]; then
              PK_MINSDK[$P_PKGNAME]=${BASH_REMATCH[1]}
            fi
            re='targetSdk=([0-9]+)'
            if [[ $zeile =~ $re ]]; then
              PK_TARGETSDK[$P_PKGNAME]=${BASH_REMATCH[1]}
            fi
            doProgress "    +versionCode: ${PK_VERSIONCODE[$P_PKGNAME]}, minSdk: ${PK_MINSDK[$P_PKGNAME]}, targetSdk: ${PK_TARGETSDK[$P_PKGNAME]}" 5
            continue
            ;;
          "versionName")
            PK_VERSION[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +version: ${PK_VERSION[$P_PKGNAME]}" 5
            continue
            ;;
          "apkSigningVersion")
            PK_SIGNINGVER[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +signingVersion: ${PK_SIGNINGVER[$P_PKGNAME]}" 5
            continue
            ;;
          "userId")
            PK_IDS[$P_PKGNAME]="$(trim "${zeile}")"
            doProgress "    +IDs: ${PK_IDS[$P_PKGNAME]}" 5
            continue
            ;;
          "dataDir")
            PK_DATADIR[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +data: ${PK_DATADIR[$P_PKGNAME]}" 5
            continue
            ;;
          "supportsScreens")
            PK_SCREENSIZE[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +screens: ${PK_SCREENSIZE[$P_PKGNAME]}" 5
            continue
            ;;
          "firstInstallTime")
            PK_FIRSTINSTALL[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +firstinst: ${PK_FIRSTINSTALL[$P_PKGNAME]}" 5
            continue
            ;;
          "lastUpdateTime")
            PK_LASTUPDATE[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +lastup: ${PK_LASTUPDATE[$P_PKGNAME]}" 5
            continue
            ;;
          "installerPackageName")
            in_array "${zeile##*=}" "${PK_INSTALLERS[@]}" || { # setting up "used sources" to group by
              if [ -z "${APP_INSTALL_SRC[${zeile##*=}]}" ]; then
                PK_INSTALLERS[${zeile##*=}]="${zeile##*=}"
              else
                PK_INSTALLERS[${zeile##*=}]="${APP_INSTALL_SRC[${zeile##*=}]}"
              fi
            }
            PK_INSTALLER[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +installer: ${PK_INSTALLER[$P_PKGNAME]}" 5
            continue
            ;;
          "flags")
            PK_FLAGS[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +flags: ${PK_FLAGS[$P_PKGNAME]}" 5
            continue
            ;;
          "privateFlags")
            PK_PRIVFLAGS[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +privFlags: ${PK_PRIVFLAGS[$P_PKGNAME]}" 5
            continue
            ;;
          "mtkFlags")
            # MTK devices only. Until now, we only know about the "OPERATOR" flag. No details what it is about.
            PK_MTKFLAGS[$P_PKGNAME]="${zeile##*=}"
            doProgress "    +flags: ${PK_MTKFLAGS[$P_PKGNAME]}" 5
            continue
            ;;
          *)
            if [[ "${zeile:0:11}" = "  Package [" ]]; then  # "  Package [com.google.android.location] (40e85638):"
              tmpstring="${zeile##*[}"                      # strip leading
              P_PKGNAME="${tmpstring%%]*}"                  # strip trailing
              doProgress "  - Package: $P_PKGNAME" 4
              continue
            fi
            regex='^\s+disabledComponents:'
            if [[ "${zeile}" =~ $regex ]]; then
              P_BLOCK="disabled"
              doProgress "    +disabledComponents" 5
              continue
            fi
            regex='^\s+enabledComponents:'
            if [[ "${zeile}" =~ $regex ]]; then
              P_BLOCK="enabled"
              doProgress "    +enabledComponents" 5
              continue
            fi
            if [[ "${zeile:0:8}" = "    User" ]]; then  # Android 4.2+ MultiUser info
              # '    User 0:  installed=true stopped=false notLaunched=false enabled=0'
              if [[ -z "${PK_USERS[$P_PKGNAME]}" ]]; then
                PK_USERS[$P_PKGNAME]="    + ${zeile:4}"
              else
                PK_USERS[$P_PKGNAME]+="\n    + ${zeile:4}"
              fi
              continue
            fi
            if [[ "${zeile:0:17}" == "    primaryCpuAbi" ]]; then # primaryCpuAbi=armeabi-v7a
              PK_PRIMARYCPU[$P_PKGNAME]="${zeile:18}"
              doProgress "    +primaryCpuAbi: ${PK_PRIMARYCPU[$P_PKGNAME]}" 5
              continue
            fi
            if [[ "${zeile:0:19}" == "    secondaryCpuAbi" ]]; then # secondaryCpuAbi=null
              PK_SECONDARYCPU[$P_PKGNAME]="${zeile:20}"
              doProgress "    +secondaryCpuAbi: ${PK_SECONDARYCPU[$P_PKGNAME]}" 5
              continue
            fi
            if [[ "${zeile:0:15}" == "    appCategory" ]]; then
              PK_APPCATEGORY[$P_PKGNAME]="${appCategory[${zeile:16}]}"
              doProgress "    +appCategory: ${PK_APPCATEGORY[$P_PKGNAME]}" 5
              continue
            fi
            # silently skip some stuff:
            if [[ "${zeile:0:24}" == "    install permissions:" || "${zeile:0:25}" == "    declared permissions:" || "${zeile:0:11}" == "    dexMode" || "${zeile:0:32}" == "    nativeLibraryRootRequiresIsa" || "${zeile:0:29}" == "    secondaryNativeLibraryDir" || "${zeile:0:20}" == "    nativeLibraryDir" || "${zeile:0:24}" == "    nativeLibraryRootDir" || "${zeile:0:26}" == "    legacyNativeLibraryDir" || "${zeile:0:10}" == "    splits" || "${zeile:0:16}" == "    compat name=" ]]; then
              continue
            fi

            oops "pkg" "${LINENO}" "Unexpected: '$zeile'" 2
            ;;
        esac
        ;;

      "disabled") # disabled components of current pkg
        if [[ -z "$zeile" ]]; then
          continue
        fi
        regex='^\s+enabledComponents:'
        if [[ "${zeile}" =~ $regex ]]; then
          P_BLOCK="enabled"
          doProgress "    +enabledComponents" 5
          continue
        fi
        if [[ "${zeile:0:6}" = "      " ]]; then
          if [[ -z "${PK_DISABLED[$P_PKGNAME]}" ]]; then
            PK_DISABLED[$P_PKGNAME]="${zeile:6}"
          else
            PK_DISABLED[$P_PKGNAME]="${PK_DISABLED[$P_PKGNAME]} ${zeile:6}"
          fi
          continue
        fi
        if [[ "${zeile}" = "    grantedPermissions:" ]]; then
          P_BLOCK="perms"
              doProgress "    +perms" 5
          continue
        fi
        if [[ "${zeile:0:11}" = "  Package [" ]]; then  # "  Package [com.google.android.location] (40e85638):"
          tmpstring="${zeile##*[}"                      # strip leading
          P_PKGNAME="${tmpstring%%]*}"                  # strip trailing
          P_BLOCK="pkg"
          doProgress "  - Package: $P_PKGNAME" 4
          continue
        fi

        if [[ "$zeile" == "Renamed packages:" ]]; then  # temporary work-around to eliminate "oops" ###TODO###
          # P_BLOCK="renamed" ...
          break
        fi

        if [[ "$zeile" == "Hidden system packages:" ]]; then # temporary work-around to eliminate "oops" ###TODO###
          # P_BLOCK="hiddensystempackages" ...
          break
        fi

        if [[ "$zeile" == "Shared users:" ]]; then      # temporary work-around to eliminate "oops" ###TODO###
          # P_BLOCK="sharedusers" ...
          break
        fi

        oops "disabled" "${LINENO}" "'$zeile'" 2
        ;;

      "enabled") # enabled components of current pkg
        if [[ "${zeile:0:6}" = "      " ]]; then
          continue # we don't include enabled components
        fi
        if [[ "${zeile}" = "    grantedPermissions:" ]]; then
          P_BLOCK="perms"
          doProgress "    +perms" 5
          continue
        fi
        if [[ "${zeile:0:11}" = "  Package [" ]]; then  # "  Package [com.google.android.location] (40e85638):"
          tmpstring="${zeile##*[}"                      # strip leading
          P_PKGNAME="${tmpstring%%]*}"                  # strip trailing
          P_BLOCK="pkg"
          doProgress "  - Package: $P_PKGNAME" 4
          continue
        fi

        oops "enabled" "${LINENO}" "$zeile" 2
        ;;

      "perms")
        if [[ "${zeile:0:6}" = "      " ]]; then
          continue # we don't include permissions (yet)
        fi
        if [[ "${zeile:0:11}" = "  Package [" ]]; then  # "  Package [com.google.android.location] (40e85638):"
          tmpstring="${zeile##*[}"                      # strip leading
          P_PKGNAME="${tmpstring%%]*}"                  # strip trailing
          P_BLOCK="pkg"
          doProgress "  - Package: $P_PKGNAME" 4
          continue
        fi

        oops "perms" "${LINENO}" "$zeile" 2
        ;;
      *)
        ;;
    esac

  done < "${PKGDUMP}"

  getAppUsage
  echo -e "#!${BASH_LOCATION}" > "${SH_DISABLED}"
  echo -e "# Disabled components on ${DEVICE_NAME} as of $(date '+%Y-%m-%d %H:%M')" >> "${SH_DISABLED}"
  echo -e "#\n# Check carefully before executing. Not all of those have been disabled by you :)\n#\n" >> "${SH_DISABLED}"

  getAppStorageStats

  [[ $((${MK_USERAPPS} + ${MK_SYSAPPS})) -ne 0 ]] && echo -n "**Apps:**" > "${DOCDIR}/apps.head"
  [[ ${MK_USERAPPS} -ne 0 ]] && _makeAppDoc "user"
  [[ ${MK_SYSAPPS}  -ne 0 ]] && _makeAppDoc "system"

  doProgress "- removing temporary dumpfile" 2
  rm -f "${PKGDUMP}" "$tmp"
}



#
# Create app documentation
# (called from getAppDetails())
# $1 = "user"|"system"
#
function _makeAppDoc() {
  local mdfile
  local apptype
  local applist
  case "${1,,}" in
    "user")
        doProgress "- generating userApps.md" 2
        mdfile="${DOCDIR}/userApps.md"
        apptype="User-Apps"
        applist=(${userApps[*]})
        echo -e "#\n# Disable User Components\n#" >> "${SH_DISABLED}"
        _retrieveAppNames=1
        ;;
    "system")
        doProgress "- generating sysApps.md" 2
        mdfile="${DOCDIR}/sysApps.md"
        apptype="System-Apps"
        applist=(${sysApps[*]})
        echo -e "\n\n#\n# Disable System Components\n#" >> "${SH_DISABLED}"
        _retrieveAppNames=${MK_SYSAPPS_RETRIEVE_NAMES}
        ;;
    *) 
        oops "makeAppDoc" "${LINENO}" "We only know about user and system apps, but got asked for '$1'" 1
        return
        ;;
  esac

  # check if aapt is available on the device, so we can use it to retrieve e.g. app names
  if [[ -z "${DUMMYDIR}" ]]; then
    local str="$(adb ${ADBOPTS} shell "ls /system/bin/aapt 2>/dev/null")"
    str=${str//[$'\t\r\n']} # stupid ^M
    if [[ "${str}" = "/system/bin/aapt" ]]; then
      local HAVE_AAPT=1
    else
      local HAVE_AAPT=0
    fi
  else
    local HAVE_AAPT=0
  fi

  echo "# Installed ${apptype} on ${DEVICE_NAME} {#${apptype/-/_}}" > "${mdfile}"
  echo -n " \[[${apptype}](#${apptype/-/_})\]" >> "${DOCDIR}/apps.head"
  echo "(As of $(date '+%Y-%m-%d %H:%M')) **<sup>[ⓘ](${WIKI_BASE}/AppDetails-explained \"Wiki\")</sup>**" >> "${mdfile}"
  declare -A PK_INFO
  for src in ${!PK_INSTALLERS[@]}; do
    PK_INFO[$src]=""
  done
  local CUR_INSTALLER
  local APPNAME
  for app in ${applist[@]}; do
    if [[ "$1" = "system" && -n "${APPCACHESPLUS}" ]]; then
      for appcache in ${APPCACHESPLUS}; do
        APPNAME=$(getAppname "${app}" "${PK_CODEPATH[$app]}" $_retrieveAppNames "${appcache}")
        [[ "${APPNAME}" != "${app}" ]] && break;
      done
      [[ "${APPNAME}" = "${app}" ]] && APPNAME=$(getAppname "${app}" "${PK_CODEPATH[$app]}" $_retrieveAppNames)
    else
      APPNAME=$(getAppname "${app}" "${PK_CODEPATH[$app]}" $_retrieveAppNames)
    fi
    if [[ -z "${PK_INSTALLER[$app]}" ]]; then # no installer
      if [[ "${APPNAME}" = "${app}" ]]; then
        tmpstring="+ **$app**\n"
      elif [[ -n "${APP_MARKET_URL[unknown]}" ]]; then
        tmpstring="+ **[${APPNAME}](${APP_MARKET_URL[unknown]/\%s/$app})**\n"
      else
        tmpstring="+ **${APPNAME} (${app})**\n"
      fi
    elif [[ -n "${APP_MARKET_URL[${PK_INSTALLER[$app]}]}" ]]; then
      tmpstring="+ **[${APPNAME}](${APP_MARKET_URL[${PK_INSTALLER[$app]}]/\%s/$app})**\n"
    else # no web source
      if [[ "${APPNAME}" = "${app}" ]]; then
        tmpstring="+ **$app**\n"
      else
        tmpstring="+ **${APPNAME} (${app})**\n"
      fi
    fi
    [[ -n "${PK_APPCATEGORY[$app]}" ]]  && tmpstring+="    + Category: ${PK_APPCATEGORY[$app]}\n"
    [[ -n "${PK_ASIZE[$app]}" ]]        && tmpstring+="    + storage used (app/data/cache): $(format_fsize ${PK_ASIZE[$app]}) / $(format_fsize ${PK_DSIZE[$app]}) / $(format_fsize ${PK_CSIZE[$app]})\n"
    [[ -n "${PK_FIRSTINSTALL[$app]}" ]] && tmpstring+="    + first installed: ${PK_FIRSTINSTALL[$app]}\n"
    [[ -n "${PK_LASTUPDATE[$app]}" ]]   && tmpstring+="    + last updated: ${PK_LASTUPDATE[$app]}\n"
    [[ -n "${PK_LASTUSED[$app]}" ]]     && tmpstring+="    + last used: ${PK_LASTUSED[$app]}\n"
    str=
    [[ -n "${PK_MINSDK[$app]}" ]]       && str+="; Android ${SDK2VER[${PK_MINSDK[$app]}]}+"
    [[ -n "${PK_TARGETSDK[$app]}" ]]    && str+="; targets Android ${SDK2VER[${PK_MINSDK[$app]}]}"
    [[ -n "${PK_VERSION[$app]}" ]]      && tmpstring+="    + installed version: ${PK_VERSION[$app]} (${PK_VERSIONCODE[$app]}${str})\n"
    [[ -n "${PK_SIGNINGVER[$app]}" ]]   && tmpstring+="    + signature scheme: ${PK_SIGNINGVER[$app]}\n"
    [[ -n "${PK_IDS[$app]}" ]]          && tmpstring+="    + IDs: ${PK_IDS[$app]}\n"
    [[ -n "${PK_CODEPATH[$app]}" ]]     && tmpstring+="    + CodePath: \`${PK_CODEPATH[$app]}\`\n"
    [[ -n "${PK_DATADIR[$app]}" ]]      && tmpstring+="    + App data: \`${PK_DATADIR[$app]}\`\n"
    [[ -n "${PK_PRIMARYCPU[$app]}" && "${PK_PRIMARYCPU[$app]}" != "null" ]]     && tmpstring+="    + Primary CPU ABI: \`${PK_PRIMARYCPU[$app]}\`\n"
    [[ -n "${PK_SECONDARYCPU[$app]}" && "${PK_SECONDARYCPU[$app]}" != "null" ]] && tmpstring+="    + Secondary CPU ABI: \`${PK_SECONDARYCPU[$app]}\`\n"
    [[ -n "${PK_SCREENSIZE[$app]}" ]]   && tmpstring+="    + supported screen sizes: ${PK_SCREENSIZE[$app]}\n"
    [[ -n "${PK_FLAGS[$app]}" ]]        && tmpstring+="    + flags: ${PK_FLAGS[$app]}\n"
    [[ -n "${PK_PRIVFLAGS[$app]}" ]]    && tmpstring+="    + privateFlags: ${PK_PRIVFLAGS[$app]}\n"
    [[ -n "${PK_MTKFLAGS[$app]}" ]]     && tmpstring+="    + mtkFlags: ${PK_MTKFLAGS[$app]}\n"
    [[ -n "${PK_USERS[$app]}" ]]        && tmpstring+="${PK_USERS[$app]}\n"
    [[ -n "${PK_DISABLED[$app]}" ]]     && {
      tmpstring+="    + <details><summary>disabled components:</summary><ul>"
      echo "" >> "${SH_DISABLED}"
      for comp in ${PK_DISABLED[$app]}; do
        tmpstring+="<li>$comp</li>"
        echo "adb ${ADBOPTS} shell \"pm disable ${app}/${comp}\"" >> "${SH_DISABLED}"
      done
      tmpstring+="</ul></details>\n"
    }
    if [[ -z "${PK_INSTALLER[$app]}" ]]; then
      PK_INFO[none]+="$tmpstring"
    else
      CUR_INSTALLER="${PK_INSTALLER[$app]}"
      PK_INFO[$CUR_INSTALLER]+="$tmpstring"
    fi
  done
  for src in ${!PK_INSTALLERS[@]}; do
    [[ -n "${PK_INFO[$src]}" ]] && {
      echo -e "## Installed from ${PK_INSTALLERS[$src]} (installer: $src)\n" >> "${mdfile}"
      echo -e "${PK_INFO[$src]}\n" >> "${mdfile}"
    }
  done
}
